"""
Dedicated output formatters for workout analysis results.

This module provides formatters that consume structured WorkoutAnalysis objects
and generate consistent, well-formatted markdown and JSON outputs with identical
data content.
"""
from typing import Any
from datetime import datetime

from analysis.models import (
    WorkoutAnalysis, SessionInfo, WorkoutMetrics, StatsSummary, 
    ZoneDistribution, ZoneAnalysis, HeartRateDrift, LapAnalysis, ERGAnalysis
)


class TimeFormatter:
    """Helper class for time formatting operations."""
    
    @staticmethod
    def seconds_to_hms(seconds: float | None) -> str:
        """Convert seconds to HH:MM:SS format."""
        if seconds is None:
            return "—"
        
        total_sec = int(seconds)
        hours = total_sec // 3600
        minutes = (total_sec % 3600) // 60
        secs = total_sec % 60
        return f"{hours:02d}:{minutes:02d}:{secs:02d}"

    @staticmethod
    def seconds_to_hms_raw(seconds: float) -> str:
        """Convert seconds to HH:MM:SS format (no None handling)."""
        total_sec = int(seconds)
        hours = total_sec // 3600
        minutes = (total_sec % 3600) // 60
        secs = total_sec % 60
        return f"{hours:02d}:{minutes:02d}:{secs:02d}"


class MarkdownFormatter:
    """Generates markdown output from WorkoutAnalysis objects."""
    
    def format(self, analysis: WorkoutAnalysis) -> str:
        """Generate complete markdown analysis."""
        lines = []
        
        # Session Information
        lines.extend(self._format_session_info(analysis))
        
        # Basic metrics and athlete settings
        lines.extend(self._format_basic_metrics(analysis))
        
        # Power analysis
        if analysis.has_power_data:
            lines.extend(self._format_power_analysis(analysis))
        
        # Heart rate analysis
        if analysis.has_heart_rate_data:
            lines.extend(self._format_heart_rate_analysis(analysis))
        
        # Cadence analysis
        if analysis.has_cadence_data:
            lines.extend(self._format_cadence_analysis(analysis))
        
        # Zone analysis
        if analysis.zones:
            lines.extend(self._format_zone_analysis(analysis))
        
        # Heart rate drift
        if analysis.heart_rate_drift:
            lines.extend(self._format_heart_rate_drift(analysis))
        
        # Lap analysis
        if analysis.laps:
            lines.extend(self._format_lap_analysis(analysis))
        
        
        # Footer
        lines.append("")
        lines.append("Generated by workout analyzer")
        
        return "\n".join(lines)
    
    def _format_session_info(self, analysis: WorkoutAnalysis) -> list[str]:
        """Format session information section."""
        lines = ["## Session Information"]
        session = analysis.session
        
        if session.name:
            lines.append(f"Name: {session.name}")
        lines.append(f"Sport: {session.sport}")
        if session.sub_sport:
            lines.append(f"Sub-sport: {session.sub_sport}")
        lines.append(f"Category: {session.category}")
        
        if session.start_time:
            lines.append(f"Start time: {session.start_time.isoformat()}")
        
        lines.append("")
        
        # Data source information
        lines.append("## Data Source Information")
        device_name = session.device_name or "Unknown"
        lines.append(f"Device: {device_name}")
        lines.append(f"Manual entry: {'Yes' if session.manual else 'No'}")
        lines.append(f"From accepted tag: {'Yes' if session.from_accepted_tag else 'No'}")
        
        # ERG mode detection summary for virtual activities
        if analysis.erg_analysis and analysis.is_virtual_activity:
            confidence = analysis.erg_analysis.confidence_level
            result = "Likely" if analysis.erg_analysis.is_erg_workout else "Unlikely"
            lines.append(f"ERG Mode: {result} ({analysis.erg_analysis.erg_laps_count}/{analysis.erg_analysis.total_laps_count} laps)")
        
        lines.append("")
        return lines
    
    def _format_basic_metrics(self, analysis: WorkoutAnalysis) -> list[str]:
        """Format basic workout metrics."""
        lines = []
        session = analysis.session
        
        lines.append(f"Total distance: {session.distance_km:.2f} km")
        lines.append(f"Moving time: {TimeFormatter.seconds_to_hms(session.duration_sec)}")
        lines.append(f"Data points: {session.data_points}")
        lines.append(f"Estimated sampling interval: {session.sample_interval:.2f} s")
        
        # Athlete reference values
        if analysis.metrics.athlete_ftp:
            lines.append(f"Athlete FTP: {analysis.metrics.athlete_ftp:.0f} W")
        if analysis.metrics.athlete_max_hr:
            lines.append(f"Athlete Max HR: {analysis.metrics.athlete_max_hr} bpm")
        if analysis.metrics.athlete_lt_hr:
            lines.append(f"Athlete Lactate Threshold: {analysis.metrics.athlete_lt_hr} bpm")
        
        lines.append("")
        return lines
    
    def _format_power_analysis(self, analysis: WorkoutAnalysis) -> list[str]:
        """Format power analysis section."""
        lines = ["## Power (W)"]
        power = analysis.metrics.power
        
        if power:
            lines.extend(self._format_stats_summary(power))
            
            if analysis.metrics.normalized_power:
                lines.append(f"Normalized Power (NP): {analysis.metrics.normalized_power:.1f} W")
            if power.mean:
                lines.append(f"Average power: {power.mean:.1f} W")
            if analysis.metrics.variability_index:
                lines.append(f"Variability Index (VI): {analysis.metrics.variability_index:.3f}")
            if analysis.metrics.intensity_factor:
                lines.append(f"Intensity Factor (IF): {analysis.metrics.intensity_factor:.3f}")
            if analysis.metrics.training_stress_score:
                lines.append(f"Training Stress Score (TSS): {analysis.metrics.training_stress_score:.1f}")
        
        lines.append("")
        return lines
    
    def _format_heart_rate_analysis(self, analysis: WorkoutAnalysis) -> list[str]:
        """Format heart rate analysis section."""
        lines = ["## Heart Rate (bpm)"]
        hr = analysis.metrics.heart_rate
        
        if hr:
            lines.extend(self._format_stats_summary(hr))
        
        lines.append("")
        return lines
    
    def _format_cadence_analysis(self, analysis: WorkoutAnalysis) -> list[str]:
        """Format cadence analysis section."""
        cadence_title = "Steps (spm)" if analysis.session.category == "running" else "Cadence (rpm)"
        lines = [f"## {cadence_title}"]
        
        cadence = analysis.metrics.cadence
        if cadence:
            lines.extend(self._format_stats_summary(cadence))
        
        lines.append("")
        return lines
    
    def _format_zone_analysis(self, analysis: WorkoutAnalysis) -> list[str]:
        """Format zone analysis sections."""
        lines = []
        
        if analysis.zones:
            # Power zones
            if analysis.zones.power_zones:
                lines.append("## Time in power zones")
                lines.extend(self._format_zone_distribution("power", analysis.zones.power_zones))
                lines.append("")
            
            # Heart rate zones
            if analysis.zones.heart_rate_zones:
                lines.append("## Time in heart rate zones")
                lines.extend(self._format_zone_distribution("heart rate", analysis.zones.heart_rate_zones))
                lines.append("")
        
        return lines
    
    def _format_heart_rate_drift(self, analysis: WorkoutAnalysis) -> list[str]:
        """Format heart rate drift section."""
        lines = ["## Heart Rate Drift"]
        drift = analysis.heart_rate_drift
        
        if drift:
            lines.append(f"Analysis duration: {TimeFormatter.seconds_to_hms(drift.duration_sec)}")
            lines.append(f"- Avg HR (P1): {drift.avg_hr_p1:.1f} bpm")
            lines.append(f"- Avg HR (P2): {drift.avg_hr_p2:.1f} bpm")
            lines.append(f"- Avg power (P1): {drift.avg_power_p1:.1f} W")
            lines.append(f"- Avg power (P2): {drift.avg_power_p2:.1f} W")
            lines.append(f"- HR/W (P1): {drift.hr_per_watt_p1:.4f}")
            lines.append(f"- HR/W (P2): {drift.hr_per_watt_p2:.4f}")
            lines.append(f"- HR drift: {drift.drift_pct:.2f} %")
        lines.append("")
        return lines
    
    def _format_lap_analysis(self, analysis: WorkoutAnalysis) -> list[str]:
        """Format lap analysis table."""
        lines = ["## Laps"]
        
        if not analysis.laps:
            lines.append("No laps found in session.")
            lines.append("")
            return lines
        
        # Generate lap table
        lines.extend(self._generate_lap_table(analysis.laps, analysis.session.category))
        lines.append("")
        return lines
    
    
    def _format_stats_summary(self, stats: StatsSummary) -> list[str]:
        """Format statistical summary."""
        lines = []
        if stats.mean is not None:
            lines.append(f"Mean: {stats.mean:.1f}")
        if stats.min is not None:
            lines.append(f"Min: {stats.min:.1f}")
        if stats.max is not None:
            lines.append(f"Max: {stats.max:.1f}")
        if stats.std is not None:
            lines.append(f"Std: {stats.std:.1f}")
        if stats.q25 is not None:
            lines.append(f"Q25: {stats.q25:.1f}")
        if stats.q50 is not None:
            lines.append(f"Median: {stats.q50:.1f}")
        if stats.q75 is not None:
            lines.append(f"Q75: {stats.q75:.1f}")
        if stats.count > 0:
            lines.append(f"Count: {stats.count}")
        return lines
    
    def _format_zone_distribution(self, zone_type: str, zones: ZoneDistribution) -> list[str]:
        """Format zone time distribution with detailed zone information."""
        lines = []
        
        if zones.total_seconds <= 0:
            return lines
        
        lines.append(f"Total time in calculation: {TimeFormatter.seconds_to_hms(zones.total_seconds)}")
        
        # Format zone details with names, ranges, and percentages
        for zone in zones.zones:
            if zone.seconds > 0:
                # Format range
                if zone.lower is None and zone.upper is None:
                    range_str = "—"
                elif zone.lower is None:
                    range_str = f"≤{int(zone.upper)}" if zone.upper is not None else "—"
                elif zone.upper is None:
                    range_str = f"{int(zone.lower)}+"
                else:
                    range_str = f"{int(zone.lower)}–{int(zone.upper)}"
                
                time_str = TimeFormatter.seconds_to_hms(zone.seconds)
                
                lines.append(
                    f"- {zone.name:<20} {range_str:<10} "
                    f"{time_str:>8} ({zone.percent:5.1f}%)"
                )
        
        return lines
    
    def _generate_lap_table(self, laps: list[LapAnalysis], category: str) -> list[str]:
        """Generate markdown table for laps."""
        lines = []
        
        # Define cadence label based on workout category
        cadence_label = "Avg spm" if category == "running" else "Avg Cad"
        
        # Table headers
        headers = [
            "Lap", "Start", "Duration", "Distance km", "NP", "Avg W", "Avg HR",
            cadence_label, "HR Drift %", "Max W", "Max HR", "Avg km/h", 
            "Elevation gain", "Elevation loss", "Avg ℃", "ERG", "Description"
        ]
        
        # Create header row
        header_row = "| " + " | ".join(headers) + " |"
        separator_row = "| " + " | ".join("---" for _ in headers) + " |"
        
        lines.append(header_row)
        lines.append(separator_row)
        
        # Add data rows
        for lap in laps:
            row_data = [
                str(lap.lap_number),
                TimeFormatter.seconds_to_hms(lap.start_time_sec),
                TimeFormatter.seconds_to_hms(lap.duration_sec),
                f"{lap.distance_km:.1f}" if lap.distance_km is not None else "—",
                f"{lap.normalized_power:.1f}" if lap.normalized_power is not None else "—",
                f"{lap.avg_power:.1f}" if lap.avg_power is not None else "—",
                f"{lap.avg_heart_rate:.1f}" if lap.avg_heart_rate is not None else "—",
                f"{lap.avg_cadence:.1f}" if lap.avg_cadence is not None else "—",
                f"{lap.hr_drift_pct:.2f}" if lap.hr_drift_pct is not None else "—",
                f"{lap.max_power:.1f}" if lap.max_power is not None else "—",
                f"{lap.max_heart_rate:.1f}" if lap.max_heart_rate is not None else "—",
                f"{lap.avg_speed_kph:.1f}" if lap.avg_speed_kph is not None else "—",
                f"{lap.elevation_gain_m:.1f}" if lap.elevation_gain_m is not None else "—",
                f"{lap.elevation_loss_m:.1f}" if lap.elevation_loss_m is not None else "—",
                f"{lap.avg_temperature_c:.1f}" if lap.avg_temperature_c is not None else "—",
                "✓" if lap.is_erg_mode else "",
                lap.description or "-"
            ]
            
            row = "| " + " | ".join(row_data) + " |"
            lines.append(row)
        
        return lines


class JSONFormatter:
    """Generates clean JSON output from WorkoutAnalysis objects."""
    
    @staticmethod
    def _round_float(value: float | None, decimals: int = 1) -> float | None:
        """Round float to specified decimal places for cleaner JSON output."""
        if value is None:
            return None
        return round(value, decimals)
    
    @staticmethod
    def _remove_none_values(data: Any) -> Any:
        """Recursively remove None values from dictionaries and lists."""
        if isinstance(data, dict):
            return {
                key: JSONFormatter._remove_none_values(value)
                for key, value in data.items()
                if value is not None
            }
        elif isinstance(data, list):
            return [
                JSONFormatter._remove_none_values(item)
                for item in data
                if item is not None
            ]
        else:
            return data
    
    def format(self, analysis: WorkoutAnalysis) -> dict[str, Any]:
        """Generate complete JSON analysis with rounded floats for LLM consumption."""
        data = {}
        
        # Analysis metadata
        data["analysis_type"] = analysis.analysis_type
        data["analysis_timestamp"] = analysis.analysis_timestamp.isoformat()
        
        # Session information
        data["session_info"] = self._format_session_info(analysis.session)
        
        # Workout metrics
        data["metrics"] = self._format_workout_metrics(analysis.metrics)
        
        # Zone analysis
        if analysis.zones:
            data["zones"] = self._format_zone_analysis(analysis.zones)
        
        # Heart rate drift
        if analysis.heart_rate_drift:
            data["heart_rate_drift"] = self._format_heart_rate_drift(analysis.heart_rate_drift)
        
        # Lap analysis
        if analysis.laps:
            data["laps"] = [self._format_lap_analysis(lap) for lap in analysis.laps]
        
        # Remove all None values before returning
        return self._remove_none_values(data)
    
    def _format_session_info(self, session: SessionInfo) -> dict[str, Any]:
        """Format session information."""
        return {
            "name": session.name,
            "sport": session.sport,
            "sub_sport": session.sub_sport,
            "category": session.category,
            "start_time": session.start_time.isoformat() if session.start_time else None,
            "distance_km": self._round_float(session.distance_km, 2),
            "duration_sec": self._round_float(session.duration_sec, 0),
            "duration": TimeFormatter.seconds_to_hms(session.duration_sec),
            "data_points": session.data_points,
            "sample_interval": self._round_float(session.sample_interval, 2),
            "device_name": session.device_name,
            "manual": session.manual,
            "from_accepted_tag": session.from_accepted_tag,
        }
    
    def _format_workout_metrics(self, metrics: WorkoutMetrics) -> dict[str, Any]:
        """Format workout metrics with rounded values."""
        data = {}
        
        # Power metrics
        if metrics.power:
            data["power"] = self._format_stats_summary(metrics.power)
            if metrics.normalized_power is not None:
                data["power"]["normalized_power"] = self._round_float(metrics.normalized_power, 1)
            if metrics.variability_index is not None:
                data["power"]["variability_index"] = self._round_float(metrics.variability_index, 3)
            if metrics.intensity_factor is not None:
                data["power"]["intensity_factor"] = self._round_float(metrics.intensity_factor, 3)
            if metrics.training_stress_score is not None:
                data["power"]["training_stress_score"] = self._round_float(metrics.training_stress_score, 1)
        
        # Heart rate metrics
        if metrics.heart_rate:
            data["heart_rate"] = self._format_stats_summary(metrics.heart_rate)
        
        # Cadence metrics
        if metrics.cadence:
            data["cadence"] = self._format_stats_summary(metrics.cadence)
        
        # Speed metrics
        if metrics.speed:
            data["speed"] = self._format_stats_summary(metrics.speed)
        
        # Athlete reference values
        athlete_data = {}
        if metrics.athlete_ftp is not None:
            athlete_data["ftp"] = self._round_float(metrics.athlete_ftp, 0)
        if metrics.athlete_max_hr is not None:
            athlete_data["max_hr"] = metrics.athlete_max_hr  # Integer, no rounding needed
        if metrics.athlete_lt_hr is not None:
            athlete_data["lt_hr"] = metrics.athlete_lt_hr  # Integer, no rounding needed
        
        if athlete_data:
            data["athlete_settings"] = athlete_data
        
        return data
    
    def _format_stats_summary(self, stats: StatsSummary) -> dict[str, Any]:
        """Format statistical summary with rounded values."""
        return {
            "mean": self._round_float(stats.mean, 1),
            "min": self._round_float(stats.min, 1),
            "max": self._round_float(stats.max, 1),
            "std": self._round_float(stats.std, 1),
            "q25": self._round_float(stats.q25, 1),
            "q50": self._round_float(stats.q50, 1),
            "q75": self._round_float(stats.q75, 1),
            "count": stats.count,
        }
    
    def _format_zone_analysis(self, zones: ZoneAnalysis) -> dict[str, Any]:
        """Format zone analysis."""
        data = {}
        
        if zones.power_zones:
            data["power_zones"] = self._format_zone_distribution(zones.power_zones)
        
        if zones.heart_rate_zones:
            data["heart_rate_zones"] = self._format_zone_distribution(zones.heart_rate_zones)
        
        return data
    
    def _format_zone_distribution(self, zones: ZoneDistribution) -> dict[str, Any]:
        """Format zone time distribution with rounded values."""
        data = {
            "total_seconds": self._round_float(zones.total_seconds, 0),
            "total_time": TimeFormatter.seconds_to_hms(zones.total_seconds),
            "sample_interval": self._round_float(zones.sample_interval, 1),
            "zones": []
        }
        
        for zone in zones.zones:
            zone_data = {
                "name": zone.name,
                "lower": self._round_float(zone.lower, 0),
                "upper": self._round_float(zone.upper, 0),
                "seconds": self._round_float(zone.seconds, 0),
                "time": TimeFormatter.seconds_to_hms(zone.seconds),
                "percent": self._round_float(zone.percent, 1)
            }
            data["zones"].append(zone_data)
        
        return data
    
    def _format_heart_rate_drift(self, drift: HeartRateDrift) -> dict[str, Any]:
        """Format heart rate drift analysis with rounded values."""
        return {
            "duration_sec": self._round_float(drift.duration_sec, 0),
            "duration": TimeFormatter.seconds_to_hms(drift.duration_sec),
            "avg_hr_p1": self._round_float(drift.avg_hr_p1, 1),
            "avg_hr_p2": self._round_float(drift.avg_hr_p2, 1),
            "avg_power_p1": self._round_float(drift.avg_power_p1, 1),
            "avg_power_p2": self._round_float(drift.avg_power_p2, 1),
            "hr_per_watt_p1": self._round_float(drift.hr_per_watt_p1, 4),
            "hr_per_watt_p2": self._round_float(drift.hr_per_watt_p2, 4),
            "drift_pct": self._round_float(drift.drift_pct, 2),
        }
    
    def _format_lap_analysis(self, lap: LapAnalysis) -> dict[str, Any]:
        """Format lap analysis with rounded values."""
        return {
            "lap_number": lap.lap_number,
            "start_time_sec": self._round_float(lap.start_time_sec, 0),
            "start_time": TimeFormatter.seconds_to_hms(lap.start_time_sec),
            "duration_sec": self._round_float(lap.duration_sec, 0),
            "duration": TimeFormatter.seconds_to_hms(lap.duration_sec),
            "distance_km": self._round_float(lap.distance_km, 1),
            "normalized_power": self._round_float(lap.normalized_power, 1),
            "avg_power": self._round_float(lap.avg_power, 1),
            "max_power": self._round_float(lap.max_power, 1),
            "avg_heart_rate": self._round_float(lap.avg_heart_rate, 1),
            "max_heart_rate": self._round_float(lap.max_heart_rate, 1),
            "hr_drift_pct": self._round_float(lap.hr_drift_pct, 2),
            "avg_cadence": self._round_float(lap.avg_cadence, 1),
            "avg_speed_kph": self._round_float(lap.avg_speed_kph, 1),
            "elevation_gain_m": self._round_float(lap.elevation_gain_m, 1),
            "elevation_loss_m": self._round_float(lap.elevation_loss_m, 1),
            "avg_temperature_c": self._round_float(lap.avg_temperature_c, 1),
            "is_erg_mode": lap.is_erg_mode,
            "intensity_type": lap.intensity_type,
            "label": lap.label,
            "power_zone": lap.power_zone,
            "description": lap.description,
        }